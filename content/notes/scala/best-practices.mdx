---
title: Scala Best Practices
date: 2020-06-19
---

Rather than using random examples from Scala projects in the wild, these are meant as my evolving "best" way of doing things.

- Scala returns the last expression in a function. Use this to return things, do not use `return` directly. It's implemented by throwing and catching a `NonLocalReturnException` and is inefficient. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#21-must-not-use-return).
- Use `val` instead of `var`. Immutable data is easier to reason about and simplifies concurrency.
- Use immutable data structures for the same reason as above. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#22-should-use-immutable-data-structures). A recursive depth-first traversal via immutable `Map`,
  ```scala
  def traverseDepthFirst(treeId: TreeId) = {
    val tree = getTree(treeId)

    @scala.annotation.tailrec
    def traverseDepthFirst(
        stack: Set[NodeId],
        visited: List[Node],
        nodeIdToAncestorIds: Map[NodeId, Set[NodeId]],
        ord: Int
    ): (List[Node], Map[NodeId, Set[NodeId]]) =
      if (stack.isEmpty) (visited, nodeIdToAncestorIds)
      else {
        val state = tree.state(stack.head)
        traverseDepthFirst(
          state.childNodeIds.filter(pId => !visited.exists(_.nodeId === pId)) ++ stack.tail,
          createNode(tree, stack.head, ord, state) :: visited,
          nodeIdToAncestorIds + (stack.head -> Option(state.ancestorNodeIds).getOrElse(Set())),
          ord + 1
        )
      }

    traverseDepthFirst(Set(tree.rootNodeId), Nil, Map[NodeId, Set[NodeId]](), 0)
  }
  ```
- Perfer `Either` to `throw`. Exceptions aren't documented in function signatures, are inefficient, and violate structured programming principles. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#27-must-not-throw-exceptions-for-validations-of-user-input-or-flow-control).
- Catch `NonFatal` instead of `Throwable` so you don't catch fatal exceptions like out-of-memory errors. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#28-must-not-catch-throwable-when-catching-exceptions).
- Use `Option` instead of `null` and do not call `Option.get`. `null` isn't documented in function signatures and is error prone since the compiler cannot protect you. Calling `Option.get` defeats the purpose of `Option`, which is to explicitly handle the `None` case. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#29-must-not-use-null).
  - Related: Prefer `Option`'s `.map` to `.isDefined`/`.isEmpty`. It's more idiomatic.
  ```scala
  // ðŸ‘Ž
  if (someOption.isDefined) s"value=${someOption.get}" else "Default"

  // ðŸ‘
  somOption.map(v => s"value=$v").getOrElse("Default")
  ```
  - Related: use `Seq.headOption` instead of `Seq.head`. The latter throws a `NoSuchElementException` on an empty list. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#220-must-not-use-seqhead).
- Prefer stronger types and pattern matching to `Any`, `AnyRef`, `isInstanceOf`, and `asInstanceOf`. These circumvent the type system that's meant to protect you. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/2-language-rules.md#212-should-not-use-any-or-anyref-or-isinstanceof--asinstanceof).
- Use `===` from the Cats library instead of `==`. The latter is syntactic sugar for Java's `.equals`, which accepts an `Object` parameter. This allows comparing values of differing types. [Details](https://typelevel.org/cats/typeclasses/eq.html).
  ```scala
  import cats.instances.string._
  import cats.syntax.eq._
  "hi" === "hi"
  ```
- Use sealed traits for enumerations (until [Scala 3 comes out](https://dotty.epfl.ch/docs/reference/enums/enums.html)). Sealed traits can only be extended in the file they're declared so the compiler knows all subtypes and can issue warnings for non-exhaustive matches. [Details](https://stackoverflow.com/a/11203867).
  ```scala
  sealed trait JobStatus {
    def value: Int
  }

  object JobStatus {
    def apply(code: Int): JobStatus =
      code match {
        case 1 => Running
        case 2 => Complete
        case _ => Invalid
      }
  }

  case object Invalid extends JobStatus {
    val value = 0
  }

  case object Running extends JobStatus {
    val value = 1
  }

  case object Complete extends JobStatus {
    val value = 2
  }
  ```
- Use simple constructor arguments for dependency injection instead of a framework.
  ```scala
  // Main.scala
  val service = Service(Database.forConfig("postgres"))

  // Service.scala
  object Service {
    def apply(db: DatabaseDef): Service =
      new Service(Mapper, Validator, new WidgetRepository(db))
  }
  ```
- Avoid hard-coding the execution context, pass it as an implicit parameter instead. [Details](https://github.com/alexandru/scala-best-practices/blob/master/sections/4-concurrency-parallelism.md#411-must-not-hardcode-the-thread-pool--execution-context).
- Declare dependencies in `project/Dependencies.scala`. If a dependency is failing to resolve, ensure you're using the [proper number of `%`](https://www.scala-sbt.org/1.x/docs/Library-Dependencies.html#Getting+the+right+Scala+version+with). To make it easier for automated dependency updates, prefer `someLib.revision` for shared version numbers over variables.
  ```scala
  // In Dependencies.scala
  import sbt._

  object Dependencies {
    lazy val someLib = "com.example" %% "core" % "1.0.0"
    lazy val otherLib = "com.example" %% "logger" % someLib.revision
  }
  ```
- `for` comprehensions are a simplified way of chaining `flatMap`s. Anything that exposes `flatMap` can be used in `for` comps. This includes `Future[T]`, `Option[T]`, `Either[T]`, etc. Use `<-` if the statement you're calling returns something you want to `flatMap` over. Otherwise, use `=`.
  ```scala
  for {
    item <- methodReturningFuture()
    myValue = 5
    res <- anotherFuture(item, myValue)
  } yield res

  // Is equivalent to,
  val res = methodReturningFuture().flatMap { item =>
    val myValue = 5
    anotherFuture(item, myValue)
  }
  ```

<!-- TODO
- Unit test with mocking (matchers \*[T] vs eqTo), Async vs Flat spec, well factored
- Integration test, reducing boilerplate, share fakes from test config
- Lefthook opt-out
- Futures, `map`, `flatMap`, `for`, `fallbackTo`, `recover`, `recoverWith`
- Error handling in repos, services, and across gRPC
- Alpakka S3, SQS, Kafka
- Akka streams, error handling, composition
- gRPC service (PRS for `Request > Service > Validator > [DO WORK] > Mapper > Response`) and endpoint, `protov.json`, protobufs (publishing versions, local publish, prototool)
- Slick lifted, plain sql, streaming
- Generics and type bounds
- Function passing
- Cats (principles/debugging errors, IO, Validated, Chains)
- Implicits
- Database schemas
- Avoid Unit returns and Await.result, instead, pass result to next function so order dependencies are clear, allows you to see parallelization opportunities
- pull things out of for comps to run in parallel or
    import cats.instances.future._
    import cats.syntax.apply._        (doSomethingAsyncA(), doSomethingAsyncB()).tupled.map {
      case (resA, resB) => CombinedResponse(resA, resB)
    }
END TODO -->
