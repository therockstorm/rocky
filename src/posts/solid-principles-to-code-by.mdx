---
title: SOLID Principles to Code By
date: "2012-05-15"
---

Uncle Bob's book [Agile Software Development, Principles, Patterns, and Practices](https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445) calls out 5 principles that aid greatly in Test-Driven Development and make programs easier to maintain and extend (definitions complements of [Wikipedia](https://en.wikipedia.org/wiki/SOLID)):

1. Single Responsibility ([SRP](https://en.wikipedia.org/wiki/Single-responsibility_principle)) - Every class should have a single responsibility, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility.
1. Open-Closed ([OCP](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)) - Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
1. Liskov Substitution ([LSP](https://en.wikipedia.org/wiki/Liskov_substitution_principle)) - If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may be substituted for objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).
1. Interface-Segregation ([ISP](https://en.wikipedia.org/wiki/Interface_segregation_principle)) - No client should be forced to depend on methods it does not use.
1. Dependency-Inversion ([DIP](https://en.wikipedia.org/wiki/Dependency_inversion_principle)) - High-level modules should not depend on low-level modules. Both should depend on abstractions. Additionally, abstractions should not depend upon details. Details should depend upon abstractions.
   - No variable should hold reference to concrete class
   - No class should derive from concrete class
   - No method should override an implemented method of any of its base classes

Another that isn't mentioned but that I have found helpful is the Law of Demeter ([LoD](https://en.wikipedia.org/wiki/Law_of_Demeter)) - An object A can call a method of an object B, but A cannot "reach through" B to access another object C to call a method. Otherwise, A implicitly requires greater knowledge of B's internal structure.
